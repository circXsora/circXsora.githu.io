---
title: 游戏中的移动处理
top: false
cover: false
toc: true
mathjax: true
date: 2020-07-11 11:56:22
password:
summary:
tags:
- Unity
- GamePlay
- C#
- Movement
- Collision
categories:
- MagiaLikeCoding
---

# CatLikeCoding

这个系列是为了学习CatLike Coding而制作的学习笔记。

### 2D中的移动

在一个平面内，控制一个小球移动，只需要改变他的x和z轴的坐标信息即可。坐标信息可以通过改变他的速度和加速度来控制。

首先需要取得用户的输入信息：

```c#
void Update(){
	Vector2 playerInput;
	playerInput.x = Input.GetAxis("Horizontal");
	playerInput.y = Input.GetAxis("Vertical");
	playerInput = Vector2.ClampMagnitude(playerInput, 1f);
}
```

`ClampMagnitude`会让用户输入的向量的最大长度限制在1。

### 直接控制速度

可以用输入的向量来直接控制速度

```c#
void Update(){		
	Vector3 velocity = new Vector3(playerInput.x, 0f, playerInput.y);
	Vector3 displacement = velocity * Time.deltaTime;
	transform.localPosition += displacement;
}
```

但这太不平滑（smooth）了，会给人一种太直接的感觉，这个比较适用于对输入特别敏感的游戏。

最后添加一个变量来控制速度的大小。

```c#
[SerializeField, Range(0f, 100f)]
float maxSpeed = 10f;

void Update(){
    //...
    Vector3 velocity =
	new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
    //...
}
```

### 加速度

加速度可以让物体获得惯性和更平滑的移动。

```c#
void Update(){
    // ...
	Vector3 acceleration =
	new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
	velocity += acceleration * Time.deltaTime;
	Vector3 displacement = velocity * Time.deltaTime;
    // ...
}
```

但加速度增加了人物移动的复杂度，使控制变得困难起来了，一般用于车辆和交通工具这类质量很大的物体。

### 如何得到想要的速度控制

可以设置加速度和速度的最大值和控制因子来实现想要的平滑速度变化

```c#
[SerializeField, Range(0f, 100f)]
float maxAcceleration = 10f;

void Update(){
	Vector3 desiredVelocity =
			new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
	float maxSpeedChange = maxAcceleration * Time.deltaTime;
    if (velocity.x < desiredVelocity.x) {
			velocity.x = Mathf.Min(velocity.x + maxSpeedChange, 										desiredVelocity.x);
	}
	else if (velocity.x > desiredVelocity.x) {
			velocity.x = Mathf.Max(velocity.x - maxSpeedChange, 											desiredVelocity.x);
	}
    // 对Z轴做同样的处理
}
```

通过调用Unity函数来简化代码：

```c#
velocity.x = Mathf.MoveTowards(velocity.x, desiredVelocity.x, 										maxSpeedChange);
velocity.z = Mathf.MoveTowards(velocity.z, desiredVelocity.z, 										maxSpeedChange);

```

### 区域限制

规定小球只能在一片区域中进行移动，而碰到墙之后则停止

```c#
[SerializeField]
Rect allowedArea = new Rect(-5f, -5f, 10f, 10f);

void Update(){
    // ...
    Vector3 newPosition = transform.localPosition + displacement;
    if (!allowedArea.Contains(new Vector2(newPosition.x, newPosition.z)) {
		newPosition = transform.localPosition;
	}
	transform.localPosition = newPosition;
}
```

但这样做有一个问题，当小球碰到左边的墙后，就不能向上下移动了。于是希望x和z轴做分别处理：

```c#
if (!allowedArea.Contains(new Vector2(newPosition.x, newPosition.z))) {
	//newPosition = transform.localPosition;
	newPosition.x =Mathf.Clamp(newPosition.x, allowedArea.xMin, 								allowedArea.xMax);
	newPosition.z = Mathf.Clamp(newPosition.z, allowedArea.yMin, 								allowedArea.yMax);
}
```

这样运行起来虽然没问题，但它还保留了原有的速度信息，使得碰到墙后再改变方向变得很慢，也需要清空小球的速度信息：

```c#
		//if (!allowedArea.Contains(new Vector2(newPosition.x, newPosition.z))) {
			//newPosition.x =
			//	Mathf.Clamp(newPosition.x, allowedArea.xMin, allowedArea.xMax);
			//newPosition.z =
			//	Mathf.Clamp(newPosition.z, allowedArea.yMin, allowedArea.yMax);
		//}
		if (newPosition.x < allowedArea.xMin) {
			newPosition.x = allowedArea.xMin;
			velocity.x = 0f;
		}
		else if (newPosition.x > allowedArea.xMax) {
			newPosition.x = allowedArea.xMax;
			velocity.x = 0f;
		}
		if (newPosition.z < allowedArea.yMin) {
			newPosition.z = allowedArea.yMin;
			velocity.z = 0f;
		}
		else if (newPosition.z > allowedArea.yMax) {
			newPosition.z = allowedArea.yMax;
			velocity.z = 0f;
		}
```

### 弹力

碰到墙后，小球如果能拥有弹力的话会更加真实，该脚本的所有代码如下：

```c#
public class MovingSphere : MonoBehaviour
{
    [SerializeField]
    Rect allowedArea = new Rect(-5f, -5f, 10f, 10f);

    [SerializeField, Range(0f, 100f)]
    float maxSpeed = 10f;

    Vector3 velocity;

    [SerializeField, Range(0f, 100f)]
    float maxAcceleration = 10f;

    [SerializeField, Range(0f, 1f)]
    float bounciness = 0.5f;

    void Update()
    {
        Vector2 playerInput;
        playerInput.x = Input.GetAxis("Horizontal");
        playerInput.y = Input.GetAxis("Vertical");
        playerInput = Vector2.ClampMagnitude(playerInput, 1f);

        Vector3 desiredVelocity =
            new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
        float maxSpeedChange = maxAcceleration * Time.deltaTime;
        velocity.x =
            Mathf.MoveTowards(velocity.x, desiredVelocity.x, maxSpeedChange);
        velocity.z =
            Mathf.MoveTowards(velocity.z, desiredVelocity.z, maxSpeedChange);

        Vector3 displacement = velocity * Time.deltaTime;
        Vector3 newPosition = transform.localPosition + displacement;
        /* 没有弹力
        if (!allowedArea.Contains(new Vector2(newPosition.x, newPosition.z)))
        {
            newPosition.x =
                Mathf.Clamp(newPosition.x, allowedArea.xMin, allowedArea.xMax);
            newPosition.z =
                Mathf.Clamp(newPosition.z, allowedArea.yMin, allowedArea.yMax);
        }
        */
        if (newPosition.x < allowedArea.xMin)
        {
            newPosition.x = allowedArea.xMin;
            velocity.x = -velocity.x * bounciness;
        }
        else if (newPosition.x > allowedArea.xMax)
        {
            newPosition.x = allowedArea.xMax;
            velocity.x = -velocity.x * bounciness;
        }
        if (newPosition.z < allowedArea.yMin)
        {
            newPosition.z = allowedArea.yMin;
            velocity.z = -velocity.z * bounciness;
        }
        else if (newPosition.z > allowedArea.yMax)
        {
            newPosition.z = allowedArea.yMax;
            velocity.z = -velocity.z * bounciness;
        }
        transform.localPosition = newPosition;
    }
}
```

