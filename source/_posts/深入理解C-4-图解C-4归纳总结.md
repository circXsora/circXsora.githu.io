---
title: 深入理解C#4+图解C#4归纳总结
top: false
cover: false
toc: true
mathjax: true
date: 2021-01-02 20:20:58
password:
summary:
tags:
categories:
---

# C#1-5

新生与诸多问题：

- 协变、逆变、不变
- 值类型和引用类型
- ......

### 值与引用

C#传递参数时是按值传递，而不是按引用传递。

- 装箱操作：将值类型赋给引用类型，在堆上创建值类型的引用副本，不对值类型进行操作
- 拆箱操作：将引用类型赋给值类型

### out与ref

out和ref的唯一区别是out参数在函数内必须要被赋值。（out可以被元组代替）

### 函数签名

函数的签名不包括返回值，无法只以返回值的不同来区分函数。

### const和readonly

Const相当于常数，不分配内存，在编译时确定。

readonly分配内存，在运行时确定，只能在构造函数和声明时被初始化。

### 方法和属性覆写（New 和override）

尽量不使用New，被强制转换成基类时会调用基类方法。override则调用最后的override方法。

### 数组

C#分为交错数组（int [\][\]，数组的数组，有多个数组）和矩形数组（int[,]只有一个数组，是多维度的）

### 枚举器和迭代器

迭代器是编译器自动生成的枚举器——IEnumerator<T>。相当于一本书的书签，是有状态的。（延迟执行）

IEnumerable<T>是可枚举类型，有GetEnumerator方法，可被Foreach遍历（foreach语句隐含了using语句，使其最后会调用迭代器中的finally语句）。相当于一本完整的书，无状态。

迭代器的实现方式为状态机。

### lambda

如果没有捕获变量，编译器会将其实现成静态方法，捕获了实例对象时则生成实例类来记录上下文，局部对象则生成嵌套类来记录上下文。

### 动态类型

动态类型的使用场景为：

- 处理反射时
- 同成员名字而不同接口（多用于测试代码）
- 动态类型库

### 可选参数和命名实参

使用时要小心如下情况：

- 参数名变化
- 默认值改动
- 重载方法时可能有问题——》不要重载有可选参数的方法

### 协变与逆变

协变性是泛型只用于输出，带有out关键字。

逆变性是泛型只用于输入，带有in关键字。

不变性则是泛型既用于输入，也用于输出。

只有接口和委托具有变体，而类和结构体没有。

协变和逆变只有隐式引用转换和一致性转换，没有值类型的转换。

在声明自己的接口和委托时，考虑是否时变体。

### 异步

在.Net1.x时代——》IAsyncResult、AsyncCallback。BeginFoo/EndFoo模型

.Net2时代——》事件驱动模型BackgroundWorker、WebClient

.Net4时代——》TPL库以及async，await关键字

使用异步的原则：

- 不要在UI线程执行长时间的操作
- 不要在UI线程以外访问UI控件

await后的续延本质是回调函数。

异步方法模型：

调用方法——》async方法——》异步操作

​				Task、void				任何可等待模式await

async用来修饰异步方法

await用来执行异步操作

void类型的async方法最好只用于事件订阅，其他都用Task返回值。

async方法有多次方法返回和一次方法完成。

**在遇到第一个await方法表达式前，方法一直以同步执行！（可能不会开启新的线程）**

异步方法参数校验如果有错，不会立刻抛出异常，但是可以写一个非Async的Task方法来校验参数。

ValueTask的使用场景是大部分情况不会执行异步操作。

使用的异步的小技巧：

- 使用ConfigureAwait（false）来避免捕获上下文
- 启动多个独立Task来实现并行
- 避免同步代码和异步代码混用
- 提供取消机制

await、async仍是是编译器通过状态机来实现的。

# C#6-8

### 调用方信息

[CallerMemeber] member = null

### 简洁代码的盛宴

- 表达式主体 =>
- 字符串特性$
- Nameof
- using static 允许值导入某类型的扩展方法
- 集合初始化器，可以在初始化器中调用索引器和扩展方法
- 异常过滤器when

### 元组

元组的比较是比较第一个元素大则为大

对动态类型的支持还很弱

元组分解在得到函数返回值时很有用。（同时可以搭配`var`和丢弃符`_`）

同时还有实例分解方法`Deconstruct`

### 模式匹配

- 匹配类型——》代替as/if
- 常量匹配
- var模式——》代替switch中的case default

以及引入了哨兵模式when

### ref

使用引用传递来提升执行效率，ref int y = ref x。此相当于C++中的引用

ref return

ref readonly

针对大型结构体和大量循环赋值拷贝操作的优化关键字。

不做性能测试的性能提升都是空谈！在使用时，做好性能测试。

### 代码简洁之道

- 局部方法
- out var
- 二进制字面量、分隔符 0b1000_0010
- default

### 可空引用类型

Class？没有`?`关键字的类型视为不可控引用类型

### 更强的模式匹配和switch表达式

### 以及更多。。。

# C#9



