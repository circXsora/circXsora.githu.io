---
title: 游戏中的移动处理その2——物理与滑坡
top: false
cover: false
toc: true
mathjax: true
date: 2020-07-11 20:05:38
password:
summary:
tags:
- Unity
- GamePlay
- C#
- Movement
- Collision
categories:
- MagiaLikeCoding
---

### 物理

unity使用rigidbody组件来完成进行物理计算，在物理运算中，不再采用可变帧率而是固定帧率。因此，在`FixedUpdate`函数中改变rigidbody的速度。

```c#
		void Awake()
        {
            body = GetComponent<Rigidbody>();
        }

		void Update()
		{
			Vector2 playerInput;
			playerInput.x = Input.GetAxis("Horizontal");
			playerInput.y = Input.GetAxis("Vertical");
			playerInput = Vector2.ClampMagnitude(playerInput, 1f);

			desiredVelocity =
				new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;
		}

		void FixedUpdate()
		{
            // 由于rigidbody的速率会受到其他物体的影响，所以需要先获取到rigidbody的速率
             velocity = body.velocity;
            									// 等效于Time.fixedDeltaTime
			float maxSpeedChange = acceleration * Time.deltaTime;
			velocity.x =
				Mathf.MoveTowards(velocity.x, desiredVelocity.x, maxSpeedChange);
			velocity.z =
				Mathf.MoveTowards(velocity.z, desiredVelocity.z, maxSpeedChange);
			body.velocity = velocity;
		}
```

### 跳跃

首先需要得到用户输入

```c#
	bool desiredJump;
	void Update () {
		// ...
		desiredJump = Input.GetButtonDown("Jump");
	}
```

不过，当用户按下跳跃键后，下一帧并不是`FixedUpdate`，而此时用户已经松开了跳跃键，那么这个操作就会被无视掉，所以需要一个小技巧来解决这个问题。

```c#
desiredJump |= Input.GetButtonDown("Jump");
```

之后在`FixedUpdate`中处理

```c#
	void FixedUpdate () {
		// ...

		if (desiredJump) {
			desiredJump = false;
			Jump();
		}
		body.velocity = velocity;
	}
	
	void Jump() {
		velocity.y += 5f;
	}
```

#### 设置跳跃的高度来反推速率

```c#
	[SerializeField, Range(0f, 10f)]
	float jumpHeight = 2f;	

	void Jump () {
		velocity.y += Mathf.Sqrt(-2f * Physics.gravity.y * jumpHeight);
	}
```

### 平面与斜坡问题

接下来需要设置小球只有在地面时才能跳跃，其判断方法是计算小球是否与平面碰撞。

而平面应该是斜度小于某个数值的才叫做平面，举个例子，墙壁并不是平面（当然，很多游戏允许人物在墙壁上不断跳跃），这个斜坡的角度可以通过计算小球与平面的接触点的法向量求出。

![contact](contact.png)

法向量的y值等于1，则表示这个平面是一个十分平坦的地面，等于0则表示是一个完全竖直的墙壁。

下面来定义小球在多少角度的斜面上才能进行跳跃

```c#
	[SerializeField, Range(0f, 90f)]
	float maxGroundAngle = 25f;	

	float minGroundDotProduct;

	void OnValidate () {
		minGroundDotProduct = Mathf.Cos(maxGroundAngle * Mathf.Deg2Rad);
	}
	
	void Awake () {
		body = GetComponent<Rigidbody>();
		OnValidate();
	}

	void OnCollisionEnter (Collision collision) {
		//onGround = true;
		EvaluateCollision(collision);
	}

	void OnCollisionStay (Collision collision) {
		//onGround = true;
		EvaluateCollision(collision);
	}

	void EvaluateCollision (Collision collision) {
		for (int i = 0; i < collision.contactCount; i++) {
			Vector3 normal = collision.GetContact(i).normal;
			onGround |= normal.y >= minGroundDotProduct;
		}
	}
```

连接点的法向量的y值其实为斜坡角度的cosine值（Y轴上的投影）。

![cos-slope-angle](cos-slope-angle.png)



### 多段跳

在很多游戏中如鬼泣，通常会有二段跳甚至三段跳，为了实现多段连跳，可以设置一个变量来记录当前的跳跃状态。

```c#
	[SerializeField, Range(0f, 100f)]
	float maxAcceleration = 10f, maxAirAcceleration = 1f;	

	[SerializeField, Range(0, 5)]
	int maxAirJumps = 0;

	int jumpPhase;
	
	void FixedUpdate () {
		UpdateState();
		// ...
	}
	void Update(){
        // ... 
        // 在空中的速率变化应该不同于在地面上的速率变化
        float acceleration = onGround ? maxAcceleration : maxAirAcceleration;
		float maxSpeedChange = acceleration * Time.deltaTime;
        // ...
    }

	void UpdateState () {
		if (onGround) { // 在地面时，多段跳跃状态清零
			jumpPhase = 0;
		}
	}

	void Jump () {
		if (onGround || jumpPhase < maxAirJumps) {
			jumpPhase += 1;
			float jumpSpeed = Mathf.Sqrt(-2f * Physics.gravity.y * jumpHeight);
			if (velocity.y > 0f) {
				jumpSpeed = Mathf.Max(jumpSpeed - velocity.y, 0f);
			}
			velocity.y += jumpSpeed;
		}
	}
```

### 在斜坡上跳跃

目前的跳跃都只是单纯向上跳跃，由于得到了斜坡的法向量，也可以让人物沿着斜坡的法向量方向进行跳跃。

```c#
	Vector3 contactNormal;

	void EvaluateCollision (Collision collision) {
		for (int i = 0; i < collision.contactCount; i++) {
			Vector3 normal = collision.GetContact(i).normal;
			//onGround |= normal.y >= minGroundDotProduct;
			if (normal.y >= minGroundDotProduct) {
				onGround = true;
				contactNormal = normal;
			}
		}
	}

	void UpdateState () {
		velocity = body.velocity;
		if (onGround) {
			jumpPhase = 0;
		}
		else { // 多段跳时，人物直接朝上跳跃
			contactNormal = Vector3.up;
		}
	}

	void Jump () {
		if (onGround || jumpPhase < maxAirJumps) {
			// ...
			//velocity.y += jumpSpeed;
			float jumpSpeed = Mathf.Sqrt(-2f * Physics.gravity.y * jumpHeight);
            // 计算投影来确保跳跃方向整体向上
			float alignedSpeed = Vector3.Dot(velocity, contactNormal);
			if (alignedSpeed > 0f) {
				jumpSpeed = Mathf.Max(jumpSpeed - alignedSpeed, 0f);
			}
			velocity += contactNormal * jumpSpeed;
		}
	}
```

### 从斜坡上滑落

至今的速度只是在xz平面上进行改变，虽然这在斜坡上通过PhysicX物理计算也能运行得很好，但在加速度非常快时就会产生弹跳从而很难进行控制。

首先来创建一个计算xz平面的速率在斜坡上的投影的函数

```c#
	Vector3 ProjectOnContactPlane (Vector3 vector) {
		return vector - contactNormal * Vector3.Dot(vector, contactNormal);
	}
```

然后计算xz方向的投影值

```c#
	void AdjustVelocity () {
		Vector3 xAxis = ProjectOnContactPlane(Vector3.right).normalized;
	    Vector3 zAxis = ProjectOnContactPlane(Vector3.forward).normalized;
        float currentX = Vector3.Dot(velocity, xAxis);
		float currentZ = Vector3.Dot(velocity, zAxis);

		float acceleration = onGround ? maxAcceleration : maxAirAcceleration;
		float maxSpeedChange = acceleration * Time.deltaTime;

		float newX =
			Mathf.MoveTowards(currentX, desiredVelocity.x, maxSpeedChange);
		float newZ =
			Mathf.MoveTowards(currentZ, desiredVelocity.z, maxSpeedChange);
        velocity += xAxis * (newX - currentX) + zAxis * (newZ - currentZ);
	}
	void FixedUpdate () {
		UpdateState();
		AdjustVelocity();
		if (desiredJump) {
			desiredJump = false;
			Jump();
		}
		body.velocity = velocity;
		onGround = false;
	}
```

### 多平面法线

一个物体可能会与多个平面进行相交，这就需要对所有的平面法线向量进行处理。

最终代码如下：

```c#
using UnityEngine;

public class MovingSphere : MonoBehaviour {

	[SerializeField, Range(0f, 100f)]
	float maxSpeed = 10f;

	[SerializeField, Range(0f, 100f)]
	float maxAcceleration = 10f, maxAirAcceleration = 1f;

	[SerializeField, Range(0f, 10f)]
	float jumpHeight = 2f;

	[SerializeField, Range(0, 5)]
	int maxAirJumps = 0;

	[SerializeField, Range(0, 90)]
	float maxGroundAngle = 25f;

	Rigidbody body;

	Vector3 velocity, desiredVelocity;

	Vector3 contactNormal;

	bool desiredJump;

	int groundContactCount;

	bool OnGround => groundContactCount > 0;

	int jumpPhase;

	float minGroundDotProduct;

	void OnValidate () {
		minGroundDotProduct = Mathf.Cos(maxGroundAngle * Mathf.Deg2Rad);
	}

	void Awake () {
		body = GetComponent<Rigidbody>();
		OnValidate();
	}

	void Update () {
		Vector2 playerInput;
		playerInput.x = Input.GetAxis("Horizontal");
		playerInput.y = Input.GetAxis("Vertical");
		playerInput = Vector2.ClampMagnitude(playerInput, 1f);

		desiredVelocity =
			new Vector3(playerInput.x, 0f, playerInput.y) * maxSpeed;

		desiredJump |= Input.GetButtonDown("Jump");
	}

	void FixedUpdate () {
		UpdateState();
		AdjustVelocity();

		if (desiredJump) {
			desiredJump = false;
			Jump();
		}

		body.velocity = velocity;
		ClearState();
	}

	void ClearState () {
		groundContactCount = 0;
		contactNormal = Vector3.zero;
	}

	void UpdateState () {
		velocity = body.velocity;
		if (OnGround) {
			jumpPhase = 0;
			if (groundContactCount > 1) {
				contactNormal.Normalize();
			}
		}
		else {
			contactNormal = Vector3.up;
		}
	}

	void AdjustVelocity () {
		Vector3 xAxis = ProjectOnContactPlane(Vector3.right).normalized;
		Vector3 zAxis = ProjectOnContactPlane(Vector3.forward).normalized;

		float currentX = Vector3.Dot(velocity, xAxis);
		float currentZ = Vector3.Dot(velocity, zAxis);

		float acceleration = OnGround ? maxAcceleration : maxAirAcceleration;
		float maxSpeedChange = acceleration * Time.deltaTime;

		float newX =
			Mathf.MoveTowards(currentX, desiredVelocity.x, maxSpeedChange);
		float newZ =
			Mathf.MoveTowards(currentZ, desiredVelocity.z, maxSpeedChange);

		velocity += xAxis * (newX - currentX) + zAxis * (newZ - currentZ);
	}

	void Jump () {
		if (OnGround || jumpPhase < maxAirJumps) {
			jumpPhase += 1;
			float jumpSpeed = Mathf.Sqrt(-2f * Physics.gravity.y * jumpHeight);
			float alignedSpeed = Vector3.Dot(velocity, contactNormal);
			if (alignedSpeed > 0f) {
				jumpSpeed = Mathf.Max(jumpSpeed - alignedSpeed, 0f);
			}
			velocity += contactNormal * jumpSpeed;
		}
	}

	void OnCollisionEnter (Collision collision) {
		EvaluateCollision(collision);
	}

	void OnCollisionStay (Collision collision) {
		EvaluateCollision(collision);
	}

	void EvaluateCollision (Collision collision) {
		for (int i = 0; i < collision.contactCount; i++) {
			Vector3 normal = collision.GetContact(i).normal;
			if (normal.y >= minGroundDotProduct) {
				groundContactCount += 1;
				contactNormal += normal;
			}
		}
	}

	Vector3 ProjectOnContactPlane (Vector3 vector) {
		return vector - contactNormal * Vector3.Dot(vector, contactNormal);
	}
}
```

